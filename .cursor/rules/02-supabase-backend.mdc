---
description: Rules for the supabase backend, including development, migrations, RLS, edge functions and storage buckets in Supabase.
alwaysApply: false
---
# Supabase Backend Development

This guide covers conventions for working on the Supabase backend for Atomic CRM.


# Supabase MCP Server
You have access to supabase mcp server and should use it.

## Database Migrations

-   All database schema changes (tables, views, functions, triggers, policies) MUST be done via migration files in `supabase/migrations/`.
-   Do not use the Supabase Studio UI to make schema changes, as they will not be tracked in version control.
-   To create a new migration, use the Supabase CLI: `npx supabase migration new <migration_name>`.
-   Refer to existing migrations for examples of creating tables, views, and RLS policies. The initial schema is in `20240730075029_init_db.sql`.

## Row Level Security (RLS)

-   RLS MUST be enabled on all tables containing user or sensitive data.
-   Policies MUST be granular. Create a separate policy for each CRUD operation (`SELECT`, `INSERT`, `UPDATE`, `DELETE`) for the `authenticated` role. Do not use a single `FOR ALL` policy.
-   While initial policies may be permissive (`using (true)`) for development, the goal is to implement ownership-based logic (e.g., `using (auth.uid() = user_id)`) before deploying to production.
-   Include comments explaining the purpose of each policy.

-   **Example Implementation**: When creating a new `widgets` table, follow this structure in your migration file:

    ```sql
    -- 1. Create the table
    create table public.widgets (
      id bigint generated by default as identity primary key,
      name text not null,
      user_id uuid references auth.users not null default auth.uid()
    );

    -- 2. Enable RLS
    alter table public.widgets enable row level security;

    -- 3. Grant permissions to the authenticated role
    grant select, insert, update, delete on table public.widgets to authenticated;

    -- 4. Create granular RLS policies
    -- Note: These are permissive. For production, they should be updated
    -- to check for ownership, e.g., using (auth.uid() = user_id).

    create policy "Allow authenticated users to view widgets"
        on public.widgets for select
        to authenticated using (true);

    create policy "Allow authenticated users to insert widgets"
        on public.widgets for insert
        to authenticated with check (true);

    create policy "Allow authenticated users to update widgets"
        on public.widgets for update
        to authenticated using (true);

    create policy "Allow authenticated users to delete widgets"
        on public.widgets for delete
        to authenticated using (true);
    ```

## Edge Functions

-   Edge functions are written in TypeScript and located in `supabase/functions/`.
-   Each function should be in its own directory.
-   Shared code between functions can be placed in `supabase/functions/_shared/`.
-   Remember to handle authentication and authorization within each edge function by verifying the user's JWT. Use `supabaseAdmin` client for elevated privileges.
-   Deploy functions using `npx supabase functions deploy`.

## Supabase Storage

Supabase Storage is used for handling user-uploaded files like company logos, contact avatars, and attachments for jobs or notes.

-   **Bucket Creation**: All storage buckets MUST be created via migration files in `supabase/migrations/`. Do not create them using the Supabase Studio UI. Buckets should be configured as private (`public: false`) unless the files are truly public.

    ```sql
    -- Example: Creating a private bucket for avatars in a migration
    insert into storage.buckets (id, name, public)
    values ('avatars', 'avatars', false);
    ```

-   **Access Control**: Access to objects in private buckets MUST be controlled by Storage RLS policies. These policies ensure data security and must be added via migration files.
    -   Policies must be granular and secure, ensuring users can only access files related to their own data.
    -   Create separate policies for `SELECT`, `INSERT`, `UPDATE`, and `DELETE` operations based on user roles and ownership.

    ```sql
    -- Example: Policy allowing authenticated users to upload their own avatar.
    create policy "allow_authenticated_avatar_uploads"
    on storage.objects for insert to authenticated with check (
      bucket_id = 'avatars' and auth.uid() = owner
    );

    -- Example: Policy allowing users to view their own avatar.
    create policy "allow_user_avatar_select"
    on storage.objects for select to authenticated using (
      bucket_id = 'avatars' and auth.uid() = owner
    );
    ```

-   **File Organization**: To avoid conflicts and simplify policy creation, organize files within buckets using a structured path. For example:
    -   **Avatars**: `user/<user_id>/avatar.<file_extension>`
    -   **Job Attachments**: `jobs/<job_id>/<file_name>`

-   **Referencing Files in the Database**: Do not store file blobs directly in the database. Instead, store a reference to the file's `path` within its bucket.
    -   **Schema**: Add a `text` or `varchar` column to your table to hold the file path (e.g., `avatar_path` on a `contacts` table).
    -   **Workflow**:
        1.  The client application uploads the file directly to Supabase Storage.
        2.  Upon successful upload, the client receives the file's `path`.
        3.  The client then saves this `path` string into the appropriate column in your database.
    -   **Retrieval**: To display or download a file, query the record from your database to get the stored path. Use this path with the Supabase client library to generate a secure, time-limited signed URL (for private files) or a public URL. This approach keeps your database lean and leverages Supabase's CDN and security features for file access.

