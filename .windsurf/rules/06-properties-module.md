---
trigger: manual
description:
globs:
---

### 1) Branch & Tracking

- Create feature branch: `feature/properties-module`.
- Keep commits small and descriptive:
  - feat(db): properties table + rls + view
  - feat(ui): properties resource CRUD
  - feat(ui): deal property link, contact properties list
  - chore: lint/build, docs update

---

### 2) Database (Migrations Only)

2.1 Create migration
```bash
npx supabase migration new properties_module
```

2.2 Migration SQL (paste in generated file)
```sql
-- 1) Properties table
create table public.properties (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  name text not null,
  contact_id bigint references public.contacts(id) on update cascade on delete set null,
  address text,
  city text,
  state text,
  zipcode text,
  country text,
  gate_code text,
  access_notes text,
  notes text,
  photos_paths text[],
  lat numeric(9,6),
  lng numeric(9,6)
);
alter table public.properties enable row level security;

grant select, insert, update, delete on table public.properties to authenticated;

create policy "properties_select" on public.properties
  for select to authenticated using (true);
create policy "properties_insert" on public.properties
  for insert to authenticated with check (true);
create policy "properties_update" on public.properties
  for update to authenticated using (true);
create policy "properties_delete" on public.properties
  for delete to authenticated using (true);

-- 2) Add property to deals (nullable)
alter table public.deals
  add column if not exists property_id bigint references public.properties(id) on update cascade on delete set null;

-- 3) Storage bucket (private) for property photos
insert into storage.buckets (id, name, public)
values ('property-photos', 'property-photos', false)
on conflict (id) do nothing;

create policy "property_photos_select"
on storage.objects for select to authenticated
using (bucket_id = 'property-photos');
create policy "property_photos_insert"
on storage.objects for insert to authenticated
with check (bucket_id = 'property-photos');
create policy "property_photos_delete"
on storage.objects for delete to authenticated
using (bucket_id = 'property-photos');

-- 4) Summary view
create view public.properties_summary
with (security_invoker=on) as
select
  p.*,
  (coalesce(c.first_name,'') || case when c.first_name is null or c.last_name is null then '' else ' ' end || coalesce(c.last_name,'')) as contact_name,
  count(d.id)::int as nb_deals,
  max(d.created_at) as last_deal_date
from public.properties p
left join public.contacts c on c.id = p.contact_id
left join public.deals d on d.property_id = p.id
group by p.id, contact_name;
```

2.3 Apply migrations
- Remote (MCP or CLI as per `/doc/developer/migrations.md`).
- npx supabase db push

Acceptance Criteria (DB):
- Table `public.properties` exists with RLS enabled and CRUD grants for `authenticated`.
- `public.deals.property_id` exists (nullable FK).
- Bucket `property-photos` exists and policies are scoped to that bucket.
- View `public.properties_summary` returns `nb_deals`, `last_deal_date`, `contact_name`.

---

### 3) Frontend (React‑Admin First)

3.1 Register resource in `src/root/CRM.tsx`
```tsx
<Resource name="properties" list={PropertyList} create={PropertyCreate} edit={PropertyEdit} show={PropertyShow} />
```

3.2 Create `src/properties/` files
- `index.ts` exporting { PropertyList, PropertyCreate, PropertyEdit, PropertyShow }
- `PropertyInputs.tsx` shared fields: `name`, `contact_id` (ReferenceInput), address fields, `gate_code`, `access_notes`, `notes`, `photos_paths` (ImageInput pattern), optional `lat`/`lng`.
- `PropertyList.tsx`:
  - Filters: `q`, `name`, `city`, optional `contact_id` (ReferenceInput).
  - Datagrid: `name`, `contact_name` (or ReferenceField), `city`, `state`, `nb_deals`, `last_deal_date`.
- `PropertyCreate.tsx`, `PropertyEdit.tsx`: RA standard with `SimpleForm` + `PropertyInputs`.
- `PropertyShow.tsx`: Details + gallery from `photos_paths` + `ReferenceManyField` of `deals` (target=`property_id`).

3.3 Wire Deals to Properties
- In `src/deals/DealInputs.tsx` add:
```tsx
<ReferenceInput source="property_id" reference="properties">
  <AutocompleteInput optionText="name" helperText={false} />
</ReferenceInput>
```
- In `src/deals/DealShow.tsx`, display linked property via `ReferenceField`.

3.4 Show Properties on Contact pages
- In Contact Show: add `ReferenceManyField` (`reference="properties"`, `target="contact_id"`) with minimal columns.

3.5 Theming/UX
- Follow density and spacing as in existing entities; use `sx` and theme tokens; no hard-coded colors.

Acceptance Criteria (UI):
- Properties resource visible in the menu; can create/edit/show records.
- Deal forms allow selecting a property; saved `property_id` persists and displays.
- Contact Show lists the contact’s properties.
- Image upload UX is consistent with existing image fields (paths stored, signed URLs generated when needed).

---

### 4) Data Provider & Filters

- Reuse existing Supabase data provider; utilize operator filters like `'city@ilike'`, full-text `q` if needed.
- Prefer querying `properties_summary` automatically if we mirror the pattern used for `companies`/`contacts` (optional v1); or query `properties` directly initially.

---

### 5) Dashboard (Optional v1)

- Add a small widget: “Recent Properties” or “No upcoming jobs” based on `nb_deals`/dates.
- Keep optional to keep v1 focused.

---

### 6) Testing & QA

Build & Lint:
- `npm run build`
- `npm run lint:check`

Smoke Scenarios:
- Create a property linked to an existing contact.
- Edit property address/access notes and confirm persistence.
- Create a deal; set `property_id`; save and verify show view displays property.
- Open a contact; verify properties list shows newly created property.
- (If gallery implemented) add photo path(s); verify render in Property Show.

Acceptance Criteria (QA):
- No TypeScript errors; no lints introduced.
- All CRUD operations for Properties succeed against Supabase.
- Deal property linkage round-trips correctly.

---

### 7) Deployment

- Apply migrations to remote using MCP Supabase or CLI per `/doc/developer/migrations.md`.
- Verify tables/view/policies exist remotely.
- Merge PR after review; run a short post-merge smoke test on staging/prod.

Rollback Plan:
- If migration causes issue, create a follow-up migration to drop added objects (`properties`, `property-photos` bucket policies, column `deals.property_id`, view) or temporarily disable the resource in UI.

---

### 8) Future Iterations (Post v1)

- Many-to-many `contact_properties` join table for property managers.
- Jobs/Scheduling: extend deals or add `jobs` with statuses and crew assignment; add calendar view.
- Ownership-based RLS (tie to `sales.user_id` and `auth.uid()`).
- Map view with geosearch using `lat`/`lng`.
- Invoicing from won deals/jobs line items.

---

### 9) Quick Checklist

- [ ] Create branch `feature/properties-module`
- [ ] Migration created and applied locally
- [ ] Properties table + RLS + grants OK
- [ ] `deals.property_id` added
- [ ] Bucket + storage policies created
- [ ] `properties_summary` view created
- [ ] Resource registered in `CRM.tsx`
- [ ] `src/properties/*` created (List/Create/Edit/Show/Inputs)
- [ ] Deal forms linked to property
- [ ] Contact Show lists properties
- [ ] Build & lint OK
- [ ] Remote migration applied; UI verified

